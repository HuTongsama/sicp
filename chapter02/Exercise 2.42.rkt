#lang sicp
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
(define (enumerate-interval n m)
  (if (> n m)
      '()
      (cons n
            (enumerate-interval (+ n 1) m))))
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(define empty-board '())
(define (safe? position)
  (define (compare-row val nums)
    (if (null? nums)
        #f
        (or (= val (car nums))
             (compare-row val (cdr nums)))))
  (define (compare-diagonal rest row dir)
    (if (null? rest)
        #f
        (or (= row (car rest))
            (compare-diagonal (cdr rest) (dir row 1) dir))))
  (let ((row (car position))
        (rest (cdr position)))
    (if (or (compare-row row rest)
             (compare-diagonal rest (+ row 1) +)
             (compare-diagonal rest (- row 1) -))
        #f
        #t)))
(define (adjoin-position row rest-of-queens)
  (cons row rest-of-queens))
(length (queens 5))
(length (queens 6))
(length (queens 7))
(length (queens 8))
